package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strings"

	_ "github.com/lib/pq"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

// Postgresql Database connectiion information, fill your data here
const (
	host     = "localhost"
	port     = 5432
	user     = "postgres"
	password = "********"
	dbname   = "gotrip"
)

// data structure to store create rule requests in memory, before save in the database
type RuleRequest struct {
	Routes []struct {
		Origin      string `json:"origin"`
		Destination string `json:"destination"`
	} `json:"routes"`
	Airlines    []string `json:"airlines"`
	Agencies    []string `json:"agencies"`
	Suppliers   []string `json:"suppliers"`
	AmountType  string   `json:"amountType"`
	AmountValue int      `json:"amountValue"`
}

// data structure to store change price requests in memory, and process them and fill Markup, PayablePrice, and RuleID if exists
type Ticket struct {
	RuleID       int    `json:"ruleId"`
	Origin       string `json:"origin"`
	Destination  string `json:"destination"`
	Airline      string `json:"airline"`
	Agency       string `json:"agency"`
	Supplier     string `json:"supplier"`
	BasePrice    int    `json:"basePrice"`
	Markup       int    `json:"markup"`
	PayablePrice int    `json:"payablePrice"`
}

// struct for response of create rule
type Resp struct {
	Status  string `json:"status"`
	Message string `json:"message"`
}

// database structure of Rule
type Rule struct {
	Id          int
	Origin      string
	Destination string
	Airlines    string
	Agencies    string
	Suppliers   string
	Amounttype  string
	Amountvalue int
}

// function to store processed rules in the database
func addRuleToDataBase(org string, dest string, aline string, agnc string, supp string, atype string, avl int, db *sql.DB) error {
	qq := fmt.Sprintf(`INSERT INTO rules (origin, destination, airlines, agencies, suppliers, amounttype, amountvalue) VALUES ('%s','%s','%s','%s','%s','%s','%d');`, org, dest, aline, agnc, supp, atype, avl)
	_, err := db.Query(qq)
	if err != nil {
		return err
	} else {
		return nil
	}
}

// function for connecting to database using  "github.com/lib/pq"
func connectDB(host string, port int, user string, password string, dbname string) *sql.DB {
	psqlInfo := fmt.Sprintf("host=%s port=%d user=%s "+
		"password=%s dbname=%s sslmode=disable",
		host, port, user, password, dbname)
	db, err := sql.Open("postgres", psqlInfo)

	// error checking of connecting to database
	if err != nil {
		log.Fatal(err)
	}
	if err := db.Ping(); err != nil {
		log.Fatal(err)
	}

	return db
}

// function for connecting to database using  "gorm"
func connectDBGorm(host string, user string, password string, dbname string, port int) *gorm.DB {
	dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%d sslmode=disable TimeZone=Asia/Tehran", host, user, password, dbname, port)
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})
	// error checking of connecting to database
	if err != nil {
		log.Fatal(err)
	}

	return db
}

// function to make tables; for now, only the table of rules is used
func createTables() {
	db := connectDB(host, port, user, password, dbname)
	qq := `
			BEGIN;
			CREATE TABLE IF NOT EXISTS "agency" ("id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, "name" varchar(50) NOT NULL);
			CREATE TABLE IF NOT EXISTS "airline" ("id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, "code" varchar(3) NOT NULL, "name" varchar(50) NOT NULL);
			CREATE TABLE IF NOT EXISTS "city" ("id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, "code" varchar(3) NOT NULL, "name" varchar(50) NOT NULL);
			CREATE TABLE IF NOT EXISTS "rules" ("id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, "origin" varchar(3) NULL, "destination" varchar(3) NULL, "airlines" text NULL, "agencies" text NULL, "suppliers" text NULL, "amounttype" varchar(10) NOT NULL, "amountvalue" integer NOT NULL);
			CREATE TABLE IF NOT EXISTS "supplier" ("id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY, "name" varchar(50) NOT NULL);
			COMMIT;`
	_, err := db.Query(qq)
	if err != nil {
		fmt.Println(err)
	}
}

func main() {

	// Creatng Tables; Just run it for the first time
	// createTables()

	{
		// handler for receiving "add rule requests" and decode request rules to our RuleRequest struct
		http.HandleFunc("/cr", func(w http.ResponseWriter, r *http.Request) {
			var rules []RuleRequest
			json.NewDecoder(r.Body).Decode(&rules)

			// connect to DB
			db := connectDB(host, port, user, password, dbname)

			// loop throug rule struct and convert it to the desired database Rule table .schema
			for _, rule := range rules {

				// convert arrays to string by joining them with ", "
				aline := strings.Join(rule.Airlines, ", ")
				agnc := strings.Join(rule.Agencies, ", ")
				supp := strings.Join(rule.Suppliers, ", ")

				// loop though routes of a rule and add each of them to one row of our rule database
				if rule.Routes != nil {
					for _, route := range rule.Routes {
						org := route.Origin
						dest := route.Destination

						// use add rule function that add rule to database returns the result of adding rule to the database
						err := addRuleToDataBase(org, dest, aline, agnc, supp, rule.AmountType, rule.AmountValue, db)

						// if error, response failed
						if err != nil {
							resp := Resp{
								Status:  "FAILED",
								Message: "Error!",
							}
							json.NewEncoder(w).Encode(resp)
						}
					}

					// if rule has no routs
				} else {
					var org string
					var dest string

					err := addRuleToDataBase(org, dest, aline, agnc, supp, rule.AmountType, rule.AmountValue, db)

					// if error, response failed
					if err != nil {
						resp := Resp{
							Status:  "FAILED",
							Message: "Error!",
						}
						json.NewEncoder(w).Encode(resp)
					}
				}
			}

			// if not any err, response success
			resp := Resp{
				Status:  "SUCCESS",
				Message: "Rules has been added to database!",
			}
			json.NewEncoder(w).Encode(resp)
		})
	}

	{

		// handler for receiving "change price requests" and decode tickets to our Ticket struct
		http.HandleFunc("/cp", func(w http.ResponseWriter, r *http.Request) {
			var tickets []Ticket
			json.NewDecoder(r.Body).Decode(&tickets)

			// connect to DB
			db := connectDBGorm(host, user, password, dbname, port)

			// get all Rules
			var rules []Rule
			db.Find(&rules)

			newTickets := make([]Ticket, len(tickets))

			// loop through tickets and calculate the payablePrice, markup and ruleId and add new tickets to new array
			for i, t := range tickets {

				// loop through rules and check if can be apply to current ticket
				for _, rule := range rules {

					if (rule.Origin == "" || rule.Origin == t.Origin) &&
						(rule.Destination == "" || rule.Destination == t.Destination) &&
						(rule.Airlines == "" || strings.Contains(rule.Airlines, t.Airline)) &&
						(rule.Agencies == "" || strings.Contains(rule.Agencies, t.Agency)) &&
						(rule.Suppliers == "" || strings.Contains(rule.Suppliers, t.Supplier)) {

						// if rule matches with ticket, calculate markup
						if rule.Amounttype == "FIXED" {
							markup := rule.Amountvalue

							// check for the most profit rule
							if markup > t.Markup {
								t.Markup = markup
							}
							// if not fixed and is percentage
						} else {
							markup := t.BasePrice * rule.Amountvalue / 100

							// check for the most profit rule
							if markup > t.Markup {
								t.Markup = markup
							}
						}

						// update PayablePrice and register ruleId to the ticket
						t.PayablePrice = t.BasePrice + t.Markup
						t.RuleID = rule.Id
					}
				}

				// add checked ticked to the new ticket slice
				newTickets[i] = t
			}

			// send the response with newTickets and new prices if ruled
			json.NewEncoder(w).Encode(newTickets)
		})

		// ListenAndServe on port 8080
		http.ListenAndServe(":8080", nil)
	}
}
